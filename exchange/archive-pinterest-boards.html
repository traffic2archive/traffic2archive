<div id="stealthIFrameContainer"></div>
<script>
/* Instrumented version of your script â€” paste in place of old script */
const fetchData = [
  	"seekersofdecay/",
  	"seekersofdecay/regan-vest/",
  	"abandoned-machine/"
];
const fetchURLs = [
  	"https://backlink-generator-tool.github.io/url-dump-json/url/custom-urls/pinterest-patch/patch-1.json"
  	//"https://backlink-generator-tool.github.io/url-dump-json/url/custom-urls/pinterest-patch/patch-2.json"
];

const archiveTodayUrls = [
  	"https://archive.today/submit/?anyway=1&url=",
  	"https://archive.li/submit/?anyway=1&url=",
  	"https://archive.vn/submit/?anyway=1&url=",
  	"https://archive.fo/submit/?anyway=1&url=",
  	"https://archive.md/submit/?anyway=1&url=",
  	"https://archive.ph/submit/?anyway=1&url="
]

const pinterestURLs = [
	"https://www.pinterest.com/",
    "https://www.pinterest.at/",
    "https://www.pinterest.be/",
    "https://www.pinterest.ca/",
    "https://www.pinterest.cl/",
    "https://www.pinterest.co/",
    "https://www.pinterest.dk/",
    "https://www.pinterest.ec/",
    "https://www.pinterest.fr/",
    "https://www.pinterest.de/",
    "https://www.pinterest.hu/",
    "https://www.pinterest.in/",
    "https://www.pinterest.id/",
    "https://www.pinterest.ie/",
    "https://www.pinterest.it/",
    "https://www.pinterest.jp/",
    "https://www.pinterest.mx/",
    "https://www.pinterest.nl/",
    "https://www.pinterest.pe/",
    "https://www.pinterest.nz/",
    "https://www.pinterest.pt/",
    "https://www.pinterest.ph/",
    "https://www.pinterest.ru/",
    "https://www.pinterest.kr/",
    "https://www.pinterest.se/",
    "https://www.pinterest.es/",
    "https://www.pinterest.ch/",
    "https://www.pinterest.tw/",
    "https://www.pinterest.uk/",
    "https://www.pinterest.th/",
    "https://www.pinterest.vn/",
    "https://www.pinterest.co.uk/",
    "https://www.pinterest.co.kr/",
    "https://www.pinterest.com.au/",
    "https://www.pinterest.com.mx/",
    "https://ar.pinterest.com/",
    "https://uk.pinterest.com/",
    "https://fr.pinterest.com/",
    "https://de.pinterest.com/",
    "https://es.pinterest.com/",
    "https://it.pinterest.com/",
    "https://au.pinterest.com/",
    "https://dk.pinterest.com/",
    "https://pt.pinterest.com/",
    "https://ru.pinterest.com/",
    "https://jp.pinterest.com/",
    "https://cl.pinterest.com/",
    "https://co.pinterest.com/",
    "https://nl.pinterest.com/",
    "https://in.pinterest.com/",
    "https://kr.pinterest.com/"
];
	
const WAYBACK_SAVE_ENDPOINTS = [
      "https://web.archive.org/save"
     
      //"https://web.archive.org/save",
      //"https://web.archive.org/",
      //"https://web.archive.org/web/*/",
      //"https://web.archive.org/web/"
  ];
const IFRAME_COUNT = 4;
const SUBMIT_INTERVAL = 60000;

function isValidURL(url) {
  const pattern = /^https?:\/\/[^\s]+$/i;
  return pattern.test(url);
}
function shuffle(array){ for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]];} }
function normalizeURL(url){ if(typeof url!=='string') return ""; return url.replace(/([^:]\/)\/+/g,"$1"); }
function randomURL(array){ return array[Math.floor(Math.random()*array.length)]; }

// --- caching configuration ---
const CACHE_KEY = "pinterest_fetchData_cache_v1";
const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours (change if you want shorter/longer)

// helper: read cache
function readFetchDataCache() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || !Array.isArray(parsed.data)) return null;
    return parsed;
  } catch (err) {
    console.warn("readFetchDataCache error:", err);
    return null;
  }
}

// helper: write cache
function writeFetchDataCache(data, meta = {}) {
  try {
    const payload = {
      ts: Date.now(),
      data: Array.isArray(data) ? data : [],
      meta
    };
    localStorage.setItem(CACHE_KEY, JSON.stringify(payload));
  } catch (err) {
    console.warn("writeFetchDataCache error:", err);
  }
}

// helper: populate global fetchData array (keeps original reference)
function populateFetchData(arr) {
  fetchData.length = 0;
  fetchData.push(...arr);
}

// Try to fetch sequentially from fetchURLs; returns array or throws
async function fetchFromNetwork() {
  shuffle(fetchURLs);
  for (const u of fetchURLs) {
    try {
      console.log("ðŸ”Ž Trying to fetch URL list from:", u);
      const r = await fetch(u, { cache: "no-store" }); // no-store to avoid browser HTTP cache interference
      if (!r.ok) throw new Error("HTTP " + r.status);
      const data = await r.json();
      if (Array.isArray(data) && data.length) {
        console.log("âœ… Network loaded", data.length, "URLs from", u);
        return { data, source: u };
      }
    } catch (err) {
      console.warn("âš  Failed to load", u, err && err.message);
    }
  }
  throw new Error("All network fetches failed");
}

// The updated function you should use
async function updateDefaultURLs() {
  // 1) Try to read cache
  const cache = readFetchDataCache();
  const now = Date.now();

  if (cache && Array.isArray(cache.data) && cache.data.length) {
    const age = now - (cache.ts || 0);
    populateFetchData(cache.data);
    console.log(`ðŸ“¥ Loaded ${cache.data.length} URLs from cache (age ${Math.round(age/1000)}s)`);

    // If cache is still fresh -> done (but still attempt background refresh if it is older than half TTL)
    if (age < CACHE_TTL_MS) {
      // background refresh if older than half TTL to keep things relatively fresh
      if (age > CACHE_TTL_MS / 2) {
        (async () => {
          try {
            const net = await fetchFromNetwork();
            writeFetchDataCache(net.data, { source: net.source });
            populateFetchData(net.data);
            console.log("ðŸ”„ Background refresh succeeded - cache updated");
          } catch (err) {
            console.warn("ðŸ”„ Background refresh failed:", err && err.message);
          }
        })();
      }
      return;
    }

    // Cache exists but expired -> attempt to refresh immediately, if fails keep expired cache
    try {
      const net = await fetchFromNetwork();
      writeFetchDataCache(net.data, { source: net.source });
      populateFetchData(net.data);
      console.log("ðŸ”ƒ Expired cache replaced with fresh network data");
      return;
    } catch (err) {
      console.warn("âš  Network refresh failed; using expired cache as fallback:", err && err.message);
      return;
    }
  }

  // 2) No cache -> fetch from network and save
  try {
    const net = await fetchFromNetwork();
    writeFetchDataCache(net.data, { source: net.source });
    populateFetchData(net.data);
    console.log("âœ… Loaded URLs from network and cached them");
    return;
  } catch (err) {
    console.warn("âŒ All fetches failed and no cache available:", err && err.message);
    // leave fetchData as-is (your existing fallback array remains)
    return;
  }
}


function generateTargetURL() {
  if (!fetchData.length) return "";
  
  const combined = randomURL(pinterestURLs) + randomURL(fetchData);
	
  return normalizeURL(combined);
}

function submitToWaybackInFrame(iframe) {
  try {
    const targetUrl = generateTargetURL();
    if (!targetUrl || !isValidURL(targetUrl)) {
      console.warn("âš  Skipping invalid target:", targetUrl);
      return;
    }
    const form = document.createElement("form");
    form.style.display = "none";
    form.target = iframe.name;
    form.method = "POST";
    form.action = randomURL(WAYBACK_SAVE_ENDPOINTS);
    form.className = "web-save-form";
    const input = document.createElement("input");
    input.type = "hidden";
    input.name = "url";
    input.value = targetUrl;
    form.appendChild(input);
    document.body.appendChild(form);

    console.log("ðŸ“¨ Submitting to Wayback in frame:", iframe.name, "target URL:", targetUrl);
    form.submit();

    // remove after a short delay to be safe
    setTimeout(() => {
      try { form.remove(); } catch(e) { /* ignore */ }
    }, 1000);
  } catch (err) {
    console.error("âŒ submitToWaybackInFrame error:", err);
  }
}

function createIframe(i) {
  try {
    const iframe = document.createElement("iframe");
    const fname = "hiddenFrame" + i;
    iframe.setAttribute("name", fname);
    iframe.setAttribute("id", fname);
    iframe.classList.add("hidden-iframe");
    // make it visible for debugging â€” remove border later if you want hidden
    iframe.style.width = "100%";
    iframe.style.height = "200px";
    iframe.style.border = "2px dashed red"; // debug border â€” remove or change to display:none if desired
    iframe.src = "about:blank";

    const container = document.getElementById("stealthIFrameContainer");
    container.appendChild(iframe);

    // wait a little so iframe is attached, then submit
    setTimeout(() => submitToWaybackInFrame(iframe), 250);

    setInterval(() => {
      console.log("â± Interval firing for iframe:", fname);
      submitToWaybackInFrame(iframe);
    }, SUBMIT_INTERVAL);
  } catch (err) {
    console.error("âŒ createIframe error:", err);
  }
}

function inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    // Accessing window.top threw an error â†’ must be in an iframe
    return true;
  }
}

/* Ensure container exists (defensive) */
if (!document.getElementById("stealthIFrameContainer")) {
  const c = document.createElement("div");
  c.id = "stealthIFrameContainer";
  document.body.appendChild(c);
  console.log("âž• Created missing stealthIFrameContainer.");
}

/* Run startup after DOM ready */
document.addEventListener('DOMContentLoaded', async () => {
  try {
    await updateDefaultURLs();
  } catch (e) {
    console.warn("updateDefaultURLs() failed:", e && e.message);
  }

	/*
	if(inIframe()){
	    updateDefaultURLs().then(() => {
	        for (let i = 0; i < IFRAME_COUNT; i++) {
	            createIframe(i);
	        }
	    });
	}else {
	    const url = randomURL(archiveTodayUrls) + encodeURIComponent(generateTargetURL());
	  	
	    window.location.href = url;
	    window.location.assign(url);
	    window.location.replace(url);
	    window.location = url;
	    document.location = url;
	    window.open(url, "_self"); // behaves like redirect
	}
	*/
	 updateDefaultURLs().then(() => {
	        for (let i = 0; i < IFRAME_COUNT; i++) {
	            createIframe(i);
	        }
	 });
});
</script>
